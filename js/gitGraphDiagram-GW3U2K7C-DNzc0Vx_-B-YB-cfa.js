var tr=Object.defineProperty,ar=Object.defineProperties;var nr=Object.getOwnPropertyDescriptors;var W=Object.getOwnPropertySymbols;var sr=Object.prototype.hasOwnProperty,or=Object.prototype.propertyIsEnumerable;var j=(t,r,e)=>r in t?tr(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,P=(t,r)=>{for(var e in r||(r={}))sr.call(r,e)&&j(t,e,r[e]);if(W)for(var e of W(r))or.call(r,e)&&j(t,e,r[e]);return t},Y=(t,r)=>ar(t,nr(r));var K=(t,r,e)=>new Promise((o,n)=>{var i=h=>{try{c(e.next(h))}catch(a){n(a)}},d=h=>{try{c(e.throw(h))}catch(a){n(a)}},c=h=>h.done?o(h.value):Promise.resolve(h.value).then(i,d);c((e=e.apply(t,r)).next())});import{p as cr}from"./chunk-353BL4L5-Dn_Y_Yna-BqbWy4Jb.js";import{I as ir}from"./chunk-AACKK3MU-DH_MKxca-adamhQof.js";import{_ as $,t as lr,q as dr,s as hr,g as $r,a as fr,b as gr,l as v,c as ur,d as yr,u as pr,E as xr,z as br,k,F as mr,G as vr,H as wr,I as Cr}from"./mermaid.core-CAqkCmS1-CM8NaR-l.js";import{p as Er}from"./treemap-75Q7IDZK-B2atdfMH-poOAsgcV.js";import"../jse/index-index-D3Xb8oT_.js";import"./bootstrap-Bf65uz2I.js";import"./_baseUniq-BXtq6_NW-DmcqD6K1.js";import"./min-BngCxx8g-CaLr7yid.js";import"./clone-CEJtuQzg-DHIwSYDi.js";var b={NORMAL:0,REVERSE:1,HIGHLIGHT:2,MERGE:3,CHERRY_PICK:4},Tr=wr.gitGraph,q=$(()=>mr(P(P({},Tr),vr().gitGraph)),"getConfig"),l=new ir(()=>{const t=q(),r=t.mainBranchName,e=t.mainBranchOrder;return{mainBranchName:r,commits:new Map,head:null,branchConfig:new Map([[r,{name:r,order:e}]]),branches:new Map([[r,null]]),currBranch:r,direction:"LR",seq:0,options:{}}});function D(){return Cr({length:7})}$(D,"getID");function X(t,r){const e=Object.create(null);return t.reduce((o,n)=>{const i=r(n);return e[i]||(e[i]=!0,o.push(n)),o},[])}$(X,"uniqBy");var Br=$(function(t){l.records.direction=t},"setDirection"),Lr=$(function(t){v.debug("options str",t),t=t==null?void 0:t.trim(),t=t||"{}";try{l.records.options=JSON.parse(t)}catch(r){v.error("error while parsing gitGraph options",r.message)}},"setOptions"),kr=$(function(){return l.records.options},"getOptions"),Mr=$(function(t){let r=t.msg,e=t.id;const o=t.type;let n=t.tags;v.info("commit",r,e,o,n),v.debug("Entering commit:",r,e,o,n);const i=q();e=k.sanitizeText(e,i),r=k.sanitizeText(r,i),n=n==null?void 0:n.map(c=>k.sanitizeText(c,i));const d={id:e||l.records.seq+"-"+D(),message:r,seq:l.records.seq++,type:o!=null?o:b.NORMAL,tags:n!=null?n:[],parents:l.records.head==null?[]:[l.records.head.id],branch:l.records.currBranch};l.records.head=d,v.info("main branch",i.mainBranchName),l.records.commits.has(d.id)&&v.warn(`Commit ID ${d.id} already exists`),l.records.commits.set(d.id,d),l.records.branches.set(l.records.currBranch,d.id),v.debug("in pushCommit "+d.id)},"commit"),Ir=$(function(t){let r=t.name;const e=t.order;if(r=k.sanitizeText(r,q()),l.records.branches.has(r))throw new Error(`Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${r}")`);l.records.branches.set(r,l.records.head!=null?l.records.head.id:null),l.records.branchConfig.set(r,{name:r,order:e}),J(r),v.debug("in createBranch")},"branch"),Rr=$(t=>{let r=t.branch,e=t.id;const o=t.type,n=t.tags,i=q();r=k.sanitizeText(r,i),e&&(e=k.sanitizeText(e,i));const d=l.records.branches.get(l.records.currBranch),c=l.records.branches.get(r),h=d?l.records.commits.get(d):void 0,a=c?l.records.commits.get(c):void 0;if(h&&a&&h.branch===r)throw new Error(`Cannot merge branch '${r}' into itself.`);if(l.records.currBranch===r){const u=new Error('Incorrect usage of "merge". Cannot merge a branch to itself');throw u.hash={text:`merge ${r}`,token:`merge ${r}`,expected:["branch abc"]},u}if(h===void 0||!h){const u=new Error(`Incorrect usage of "merge". Current branch (${l.records.currBranch})has no commits`);throw u.hash={text:`merge ${r}`,token:`merge ${r}`,expected:["commit"]},u}if(!l.records.branches.has(r)){const u=new Error('Incorrect usage of "merge". Branch to be merged ('+r+") does not exist");throw u.hash={text:`merge ${r}`,token:`merge ${r}`,expected:[`branch ${r}`]},u}if(a===void 0||!a){const u=new Error('Incorrect usage of "merge". Branch to be merged ('+r+") has no commits");throw u.hash={text:`merge ${r}`,token:`merge ${r}`,expected:['"commit"']},u}if(h===a){const u=new Error('Incorrect usage of "merge". Both branches have same head');throw u.hash={text:`merge ${r}`,token:`merge ${r}`,expected:["branch abc"]},u}if(e&&l.records.commits.has(e)){const u=new Error('Incorrect usage of "merge". Commit with id:'+e+" already exists, use different custom id");throw u.hash={text:`merge ${r} ${e} ${o} ${n==null?void 0:n.join(" ")}`,token:`merge ${r} ${e} ${o} ${n==null?void 0:n.join(" ")}`,expected:[`merge ${r} ${e}_UNIQUE ${o} ${n==null?void 0:n.join(" ")}`]},u}const s=c||"",x={id:e||`${l.records.seq}-${D()}`,message:`merged branch ${r} into ${l.records.currBranch}`,seq:l.records.seq++,parents:l.records.head==null?[]:[l.records.head.id,s],branch:l.records.currBranch,type:b.MERGE,customType:o,customId:!!e,tags:n!=null?n:[]};l.records.head=x,l.records.commits.set(x.id,x),l.records.branches.set(l.records.currBranch,x.id),v.debug(l.records.branches),v.debug("in mergeBranch")},"merge"),Gr=$(function(t){let r=t.id,e=t.targetId,o=t.tags,n=t.parent;v.debug("Entering cherryPick:",r,e,o);const i=q();if(r=k.sanitizeText(r,i),e=k.sanitizeText(e,i),o=o==null?void 0:o.map(h=>k.sanitizeText(h,i)),n=k.sanitizeText(n,i),!r||!l.records.commits.has(r)){const h=new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');throw h.hash={text:`cherryPick ${r} ${e}`,token:`cherryPick ${r} ${e}`,expected:["cherry-pick abc"]},h}const d=l.records.commits.get(r);if(d===void 0||!d)throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');if(n&&!(Array.isArray(d.parents)&&d.parents.includes(n)))throw new Error("Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.");const c=d.branch;if(d.type===b.MERGE&&!n)throw new Error("Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.");if(!e||!l.records.commits.has(e)){if(c===l.records.currBranch){const x=new Error('Incorrect usage of "cherryPick". Source commit is already on current branch');throw x.hash={text:`cherryPick ${r} ${e}`,token:`cherryPick ${r} ${e}`,expected:["cherry-pick abc"]},x}const h=l.records.branches.get(l.records.currBranch);if(h===void 0||!h){const x=new Error(`Incorrect usage of "cherry-pick". Current branch (${l.records.currBranch})has no commits`);throw x.hash={text:`cherryPick ${r} ${e}`,token:`cherryPick ${r} ${e}`,expected:["cherry-pick abc"]},x}const a=l.records.commits.get(h);if(a===void 0||!a){const x=new Error(`Incorrect usage of "cherry-pick". Current branch (${l.records.currBranch})has no commits`);throw x.hash={text:`cherryPick ${r} ${e}`,token:`cherryPick ${r} ${e}`,expected:["cherry-pick abc"]},x}const s={id:l.records.seq+"-"+D(),message:`cherry-picked ${d==null?void 0:d.message} into ${l.records.currBranch}`,seq:l.records.seq++,parents:l.records.head==null?[]:[l.records.head.id,d.id],branch:l.records.currBranch,type:b.CHERRY_PICK,tags:o?o.filter(Boolean):[`cherry-pick:${d.id}${d.type===b.MERGE?`|parent:${n}`:""}`]};l.records.head=s,l.records.commits.set(s.id,s),l.records.branches.set(l.records.currBranch,s.id),v.debug(l.records.branches),v.debug("in cherryPick")}},"cherryPick"),J=$(function(t){var r;if(t=k.sanitizeText(t,q()),l.records.branches.has(t)){l.records.currBranch=t;const e=l.records.branches.get(l.records.currBranch);e===void 0||!e?l.records.head=null:l.records.head=(r=l.records.commits.get(e))!=null?r:null}else{const e=new Error(`Trying to checkout branch which is not yet created. (Help try using "branch ${t}")`);throw e.hash={text:`checkout ${t}`,token:`checkout ${t}`,expected:[`branch ${t}`]},e}},"checkout");function N(t,r,e){const o=t.indexOf(r);o===-1?t.push(e):t.splice(o,1,e)}$(N,"upsert");function S(t){const r=t.reduce((n,i)=>n.seq>i.seq?n:i,t[0]);let e="";t.forEach(function(n){n===r?e+="	*":e+="	|"});const o=[e,r.id,r.seq];for(const n in l.records.branches)l.records.branches.get(n)===r.id&&o.push(n);if(v.debug(o.join(" ")),r.parents&&r.parents.length==2&&r.parents[0]&&r.parents[1]){const n=l.records.commits.get(r.parents[0]);N(t,r,n),r.parents[1]&&t.push(l.records.commits.get(r.parents[1]))}else{if(r.parents.length==0)return;if(r.parents[0]){const n=l.records.commits.get(r.parents[0]);N(t,r,n)}}t=X(t,n=>n.id),S(t)}$(S,"prettyPrintCommitHistory");var _r=$(function(){v.debug(l.records.commits);const t=Q()[0];S([t])},"prettyPrint"),Or=$(function(){l.reset(),br()},"clear"),qr=$(function(){return[...l.records.branchConfig.values()].map((r,e)=>r.order!==null&&r.order!==void 0?r:Y(P({},r),{order:parseFloat(`0.${e}`)})).sort((r,e)=>{var o,n;return((o=r.order)!=null?o:0)-((n=e.order)!=null?n:0)}).map(({name:r})=>({name:r}))},"getBranchesAsObjArray"),Ar=$(function(){return l.records.branches},"getBranches"),Hr=$(function(){return l.records.commits},"getCommits"),Q=$(function(){const t=[...l.records.commits.values()];return t.forEach(function(r){v.debug(r.id)}),t.sort((r,e)=>r.seq-e.seq),t},"getCommitsArray"),Pr=$(function(){return l.records.currBranch},"getCurrentBranch"),zr=$(function(){return l.records.direction},"getDirection"),Fr=$(function(){return l.records.head},"getHead"),Z={commitType:b,getConfig:q,setDirection:Br,setOptions:Lr,getOptions:kr,commit:Mr,branch:Ir,merge:Rr,cherryPick:Gr,checkout:J,prettyPrint:_r,clear:Or,getBranchesAsObjArray:qr,getBranches:Ar,getCommits:Hr,getCommitsArray:Q,getCurrentBranch:Pr,getDirection:zr,getHead:Fr,setAccTitle:gr,getAccTitle:fr,getAccDescription:$r,setAccDescription:hr,setDiagramTitle:dr,getDiagramTitle:lr},Dr=$((t,r)=>{cr(t,r),t.dir&&r.setDirection(t.dir);for(const e of t.statements)Nr(e,r)},"populate"),Nr=$((t,r)=>{const o={Commit:$(n=>r.commit(Sr(n)),"Commit"),Branch:$(n=>r.branch(Wr(n)),"Branch"),Merge:$(n=>r.merge(jr(n)),"Merge"),Checkout:$(n=>r.checkout(Yr(n)),"Checkout"),CherryPicking:$(n=>r.cherryPick(Kr(n)),"CherryPicking")}[t.$type];o?o(t):v.error(`Unknown statement type: ${t.$type}`)},"parseStatement"),Sr=$(t=>{var e,o;return{id:t.id,msg:(e=t.message)!=null?e:"",type:t.type!==void 0?b[t.type]:b.NORMAL,tags:(o=t.tags)!=null?o:void 0}},"parseCommit"),Wr=$(t=>{var e;return{name:t.name,order:(e=t.order)!=null?e:0}},"parseBranch"),jr=$(t=>{var e,o;return{branch:t.branch,id:(e=t.id)!=null?e:"",type:t.type!==void 0?b[t.type]:void 0,tags:(o=t.tags)!=null?o:void 0}},"parseMerge"),Yr=$(t=>t.branch,"parseCheckout"),Kr=$(t=>{var r;return{id:t.id,targetId:"",tags:((r=t.tags)==null?void 0:r.length)===0?void 0:t.tags,parent:t.parent}},"parseCherryPicking"),Ur={parse:$(t=>K(null,null,function*(){const r=yield Er("gitGraph",t);v.debug(r),Dr(r,Z)}),"parse")},U=ur(),C=U==null?void 0:U.gitGraph,G=10,_=40,M=4,I=2,O=8,T=new Map,B=new Map,z=30,A=new Map,F=[],R=0,p="LR",Vr=$(()=>{T.clear(),B.clear(),A.clear(),R=0,F=[],p="LR"},"clear"),rr=$(t=>{const r=document.createElementNS("http://www.w3.org/2000/svg","text");return(typeof t=="string"?t.split(/\\n|\n|<br\s*\/?>/gi):t).forEach(o=>{const n=document.createElementNS("http://www.w3.org/2000/svg","tspan");n.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve"),n.setAttribute("dy","1em"),n.setAttribute("x","0"),n.setAttribute("class","row"),n.textContent=o.trim(),r.appendChild(n)}),r},"drawText"),er=$(t=>{let r,e,o;return p==="BT"?(e=$((n,i)=>n<=i,"comparisonFunc"),o=1/0):(e=$((n,i)=>n>=i,"comparisonFunc"),o=0),t.forEach(n=>{var i,d;const c=p==="TB"||p=="BT"?(i=B.get(n))==null?void 0:i.y:(d=B.get(n))==null?void 0:d.x;c!==void 0&&e(c,o)&&(r=n,o=c)}),r},"findClosestParent"),Xr=$(t=>{let r="",e=1/0;return t.forEach(o=>{const n=B.get(o).y;n<=e&&(r=o,e=n)}),r||void 0},"findClosestParentBT"),Jr=$((t,r,e)=>{let o=e,n=e;const i=[];t.forEach(d=>{const c=r.get(d);if(!c)throw new Error(`Commit not found for key ${d}`);c.parents.length?(o=Zr(c),n=Math.max(o,n)):i.push(c),re(c,o)}),o=n,i.forEach(d=>{ee(d,o,e)}),t.forEach(d=>{const c=r.get(d);if(c!=null&&c.parents.length){const h=Xr(c.parents);o=B.get(h).y-_,o<=n&&(n=o);const a=T.get(c.branch).pos,s=o-G;B.set(c.id,{x:a,y:s})}})},"setParallelBTPos"),Qr=$(t=>{var r;const e=er(t.parents.filter(n=>n!==null));if(!e)throw new Error(`Closest parent not found for commit ${t.id}`);const o=(r=B.get(e))==null?void 0:r.y;if(o===void 0)throw new Error(`Closest parent position not found for commit ${t.id}`);return o},"findClosestParentPos"),Zr=$(t=>Qr(t)+_,"calculateCommitPosition"),re=$((t,r)=>{const e=T.get(t.branch);if(!e)throw new Error(`Branch not found for commit ${t.id}`);const o=e.pos,n=r+G;return B.set(t.id,{x:o,y:n}),{x:o,y:n}},"setCommitPosition"),ee=$((t,r,e)=>{const o=T.get(t.branch);if(!o)throw new Error(`Branch not found for commit ${t.id}`);const n=r+e,i=o.pos;B.set(t.id,{x:i,y:n})},"setRootPosition"),te=$((t,r,e,o,n,i)=>{if(i===b.HIGHLIGHT)t.append("rect").attr("x",e.x-10).attr("y",e.y-10).attr("width",20).attr("height",20).attr("class",`commit ${r.id} commit-highlight${n%O} ${o}-outer`),t.append("rect").attr("x",e.x-6).attr("y",e.y-6).attr("width",12).attr("height",12).attr("class",`commit ${r.id} commit${n%O} ${o}-inner`);else if(i===b.CHERRY_PICK)t.append("circle").attr("cx",e.x).attr("cy",e.y).attr("r",10).attr("class",`commit ${r.id} ${o}`),t.append("circle").attr("cx",e.x-3).attr("cy",e.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${r.id} ${o}`),t.append("circle").attr("cx",e.x+3).attr("cy",e.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${r.id} ${o}`),t.append("line").attr("x1",e.x+3).attr("y1",e.y+1).attr("x2",e.x).attr("y2",e.y-5).attr("stroke","#fff").attr("class",`commit ${r.id} ${o}`),t.append("line").attr("x1",e.x-3).attr("y1",e.y+1).attr("x2",e.x).attr("y2",e.y-5).attr("stroke","#fff").attr("class",`commit ${r.id} ${o}`);else{const d=t.append("circle");if(d.attr("cx",e.x),d.attr("cy",e.y),d.attr("r",r.type===b.MERGE?9:10),d.attr("class",`commit ${r.id} commit${n%O}`),i===b.MERGE){const c=t.append("circle");c.attr("cx",e.x),c.attr("cy",e.y),c.attr("r",6),c.attr("class",`commit ${o} ${r.id} commit${n%O}`)}i===b.REVERSE&&t.append("path").attr("d",`M ${e.x-5},${e.y-5}L${e.x+5},${e.y+5}M${e.x-5},${e.y+5}L${e.x+5},${e.y-5}`).attr("class",`commit ${o} ${r.id} commit${n%O}`)}},"drawCommitBullet"),ae=$((t,r,e,o)=>{var n;if(r.type!==b.CHERRY_PICK&&(r.customId&&r.type===b.MERGE||r.type!==b.MERGE)&&(C!=null&&C.showCommitLabel)){const i=t.append("g"),d=i.insert("rect").attr("class","commit-label-bkg"),c=i.append("text").attr("x",o).attr("y",e.y+25).attr("class","commit-label").text(r.id),h=(n=c.node())==null?void 0:n.getBBox();if(h&&(d.attr("x",e.posWithOffset-h.width/2-I).attr("y",e.y+13.5).attr("width",h.width+2*I).attr("height",h.height+2*I),p==="TB"||p==="BT"?(d.attr("x",e.x-(h.width+4*M+5)).attr("y",e.y-12),c.attr("x",e.x-(h.width+4*M)).attr("y",e.y+h.height-12)):c.attr("x",e.posWithOffset-h.width/2),C.rotateCommitLabel))if(p==="TB"||p==="BT")c.attr("transform","rotate(-45, "+e.x+", "+e.y+")"),d.attr("transform","rotate(-45, "+e.x+", "+e.y+")");else{const a=-7.5-(h.width+10)/25*9.5,s=10+h.width/25*8.5;i.attr("transform","translate("+a+", "+s+") rotate(-45, "+o+", "+e.y+")")}}},"drawCommitLabel"),ne=$((t,r,e,o)=>{var n;if(r.tags.length>0){let i=0,d=0,c=0;const h=[];for(const a of r.tags.reverse()){const s=t.insert("polygon"),x=t.append("circle"),u=t.append("text").attr("y",e.y-16-i).attr("class","tag-label").text(a),g=(n=u.node())==null?void 0:n.getBBox();if(!g)throw new Error("Tag bbox not found");d=Math.max(d,g.width),c=Math.max(c,g.height),u.attr("x",e.posWithOffset-g.width/2),h.push({tag:u,hole:x,rect:s,yOffset:i}),i+=20}for(const{tag:a,hole:s,rect:x,yOffset:u}of h){const g=c/2,f=e.y-19.2-u;if(x.attr("class","tag-label-bkg").attr("points",`
      ${o-d/2-M/2},${f+I}  
      ${o-d/2-M/2},${f-I}
      ${e.posWithOffset-d/2-M},${f-g-I}
      ${e.posWithOffset+d/2+M},${f-g-I}
      ${e.posWithOffset+d/2+M},${f+g+I}
      ${e.posWithOffset-d/2-M},${f+g+I}`),s.attr("cy",f).attr("cx",o-d/2+M/2).attr("r",1.5).attr("class","tag-hole"),p==="TB"||p==="BT"){const y=o+u;x.attr("class","tag-label-bkg").attr("points",`
        ${e.x},${y+2}
        ${e.x},${y-2}
        ${e.x+G},${y-g-2}
        ${e.x+G+d+4},${y-g-2}
        ${e.x+G+d+4},${y+g+2}
        ${e.x+G},${y+g+2}`).attr("transform","translate(12,12) rotate(45, "+e.x+","+o+")"),s.attr("cx",e.x+M/2).attr("cy",y).attr("transform","translate(12,12) rotate(45, "+e.x+","+o+")"),a.attr("x",e.x+5).attr("y",y+3).attr("transform","translate(14,14) rotate(45, "+e.x+","+o+")")}}}},"drawCommitTags"),se=$(t=>{var e;switch((e=t.customType)!=null?e:t.type){case b.NORMAL:return"commit-normal";case b.REVERSE:return"commit-reverse";case b.HIGHLIGHT:return"commit-highlight";case b.MERGE:return"commit-merge";case b.CHERRY_PICK:return"commit-cherry-pick";default:return"commit-normal"}},"getCommitClassType"),oe=$((t,r,e,o)=>{var i,d,c;const n={x:0,y:0};if(t.parents.length>0){const h=er(t.parents);if(h){const a=(i=o.get(h))!=null?i:n;return r==="TB"?a.y+_:r==="BT"?((d=o.get(t.id))!=null?d:n).y-_:a.x+_}}else return r==="TB"?z:r==="BT"?((c=o.get(t.id))!=null?c:n).y-_:0;return 0},"calculatePosition"),ce=$((t,r,e)=>{var o,n;const i=p==="BT"&&e?r:r+G,d=p==="TB"||p==="BT"?i:(o=T.get(t.branch))==null?void 0:o.pos,c=p==="TB"||p==="BT"?(n=T.get(t.branch))==null?void 0:n.pos:i;if(c===void 0||d===void 0)throw new Error(`Position were undefined for commit ${t.id}`);return{x:c,y:d,posWithOffset:i}},"getCommitPosition"),V=$((t,r,e)=>{var s;if(!C)throw new Error("GitGraph config not found");const o=t.append("g").attr("class","commit-bullets"),n=t.append("g").attr("class","commit-labels");let i=p==="TB"||p==="BT"?z:0;const d=[...r.keys()],c=(s=C==null?void 0:C.parallelCommits)!=null?s:!1,h=$((x,u)=>{var g,f;const y=(g=r.get(x))==null?void 0:g.seq,E=(f=r.get(u))==null?void 0:f.seq;return y!==void 0&&E!==void 0?y-E:0},"sortKeys");let a=d.sort(h);p==="BT"&&(c&&Jr(a,r,i),a=a.reverse()),a.forEach(x=>{var y,E;var u;const g=r.get(x);if(!g)throw new Error(`Commit not found for key ${x}`);c&&(i=oe(g,p,i,B));const f=ce(g,i,c);if(e){const m=se(g),L=(y=g.customType)!=null?y:g.type,w=(E=(u=T.get(g.branch))==null?void 0:u.index)!=null?E:0;te(o,g,f,m,w,L),ae(n,g,f,i),ne(n,g,f,i)}p==="TB"||p==="BT"?B.set(g.id,{x:f.x,y:f.posWithOffset}):B.set(g.id,{x:f.posWithOffset,y:f.y}),i=p==="BT"&&c?i+_:i+_+G,i>R&&(R=i)})},"drawCommits"),ie=$((t,r,e,o,n)=>{const d=(p==="TB"||p==="BT"?e.x<o.x:e.y<o.y)?r.branch:t.branch,c=$(a=>a.branch===d,"isOnBranchToGetCurve"),h=$(a=>a.seq>t.seq&&a.seq<r.seq,"isBetweenCommits");return[...n.values()].some(a=>h(a)&&c(a))},"shouldRerouteArrow"),H=$((t,r,e=0)=>{const o=t+Math.abs(t-r)/2;if(e>5)return o;if(F.every(d=>Math.abs(d-o)>=10))return F.push(o),o;const i=Math.abs(t-r);return H(t,r-i/5,e+1)},"findLane"),le=$((t,r,e,o)=>{var n,i,d,c,h;const a=B.get(r.id),s=B.get(e.id);if(a===void 0||s===void 0)throw new Error(`Commit positions not found for commits ${r.id} and ${e.id}`);const x=ie(r,e,a,s,o);let u="",g="",f=0,y=0,E=(n=T.get(e.branch))==null?void 0:n.index;e.type===b.MERGE&&r.id!==e.parents[0]&&(E=(i=T.get(r.branch))==null?void 0:i.index);let m;if(x){u="A 10 10, 0, 0, 0,",g="A 10 10, 0, 0, 1,",f=10,y=10;const L=a.y<s.y?H(a.y,s.y):H(s.y,a.y),w=a.x<s.x?H(a.x,s.x):H(s.x,a.x);p==="TB"?a.x<s.x?m=`M ${a.x} ${a.y} L ${w-f} ${a.y} ${g} ${w} ${a.y+y} L ${w} ${s.y-f} ${u} ${w+y} ${s.y} L ${s.x} ${s.y}`:(E=(d=T.get(r.branch))==null?void 0:d.index,m=`M ${a.x} ${a.y} L ${w+f} ${a.y} ${u} ${w} ${a.y+y} L ${w} ${s.y-f} ${g} ${w-y} ${s.y} L ${s.x} ${s.y}`):p==="BT"?a.x<s.x?m=`M ${a.x} ${a.y} L ${w-f} ${a.y} ${u} ${w} ${a.y-y} L ${w} ${s.y+f} ${g} ${w+y} ${s.y} L ${s.x} ${s.y}`:(E=(c=T.get(r.branch))==null?void 0:c.index,m=`M ${a.x} ${a.y} L ${w+f} ${a.y} ${g} ${w} ${a.y-y} L ${w} ${s.y+f} ${u} ${w-y} ${s.y} L ${s.x} ${s.y}`):a.y<s.y?m=`M ${a.x} ${a.y} L ${a.x} ${L-f} ${u} ${a.x+y} ${L} L ${s.x-f} ${L} ${g} ${s.x} ${L+y} L ${s.x} ${s.y}`:(E=(h=T.get(r.branch))==null?void 0:h.index,m=`M ${a.x} ${a.y} L ${a.x} ${L+f} ${g} ${a.x+y} ${L} L ${s.x-f} ${L} ${u} ${s.x} ${L-y} L ${s.x} ${s.y}`)}else u="A 20 20, 0, 0, 0,",g="A 20 20, 0, 0, 1,",f=20,y=20,p==="TB"?(a.x<s.x&&(e.type===b.MERGE&&r.id!==e.parents[0]?m=`M ${a.x} ${a.y} L ${a.x} ${s.y-f} ${u} ${a.x+y} ${s.y} L ${s.x} ${s.y}`:m=`M ${a.x} ${a.y} L ${s.x-f} ${a.y} ${g} ${s.x} ${a.y+y} L ${s.x} ${s.y}`),a.x>s.x&&(u="A 20 20, 0, 0, 0,",g="A 20 20, 0, 0, 1,",f=20,y=20,e.type===b.MERGE&&r.id!==e.parents[0]?m=`M ${a.x} ${a.y} L ${a.x} ${s.y-f} ${g} ${a.x-y} ${s.y} L ${s.x} ${s.y}`:m=`M ${a.x} ${a.y} L ${s.x+f} ${a.y} ${u} ${s.x} ${a.y+y} L ${s.x} ${s.y}`),a.x===s.x&&(m=`M ${a.x} ${a.y} L ${s.x} ${s.y}`)):p==="BT"?(a.x<s.x&&(e.type===b.MERGE&&r.id!==e.parents[0]?m=`M ${a.x} ${a.y} L ${a.x} ${s.y+f} ${g} ${a.x+y} ${s.y} L ${s.x} ${s.y}`:m=`M ${a.x} ${a.y} L ${s.x-f} ${a.y} ${u} ${s.x} ${a.y-y} L ${s.x} ${s.y}`),a.x>s.x&&(u="A 20 20, 0, 0, 0,",g="A 20 20, 0, 0, 1,",f=20,y=20,e.type===b.MERGE&&r.id!==e.parents[0]?m=`M ${a.x} ${a.y} L ${a.x} ${s.y+f} ${u} ${a.x-y} ${s.y} L ${s.x} ${s.y}`:m=`M ${a.x} ${a.y} L ${s.x-f} ${a.y} ${u} ${s.x} ${a.y-y} L ${s.x} ${s.y}`),a.x===s.x&&(m=`M ${a.x} ${a.y} L ${s.x} ${s.y}`)):(a.y<s.y&&(e.type===b.MERGE&&r.id!==e.parents[0]?m=`M ${a.x} ${a.y} L ${s.x-f} ${a.y} ${g} ${s.x} ${a.y+y} L ${s.x} ${s.y}`:m=`M ${a.x} ${a.y} L ${a.x} ${s.y-f} ${u} ${a.x+y} ${s.y} L ${s.x} ${s.y}`),a.y>s.y&&(e.type===b.MERGE&&r.id!==e.parents[0]?m=`M ${a.x} ${a.y} L ${s.x-f} ${a.y} ${u} ${s.x} ${a.y-y} L ${s.x} ${s.y}`:m=`M ${a.x} ${a.y} L ${a.x} ${s.y+f} ${g} ${a.x+y} ${s.y} L ${s.x} ${s.y}`),a.y===s.y&&(m=`M ${a.x} ${a.y} L ${s.x} ${s.y}`));if(m===void 0)throw new Error("Line definition not found");t.append("path").attr("d",m).attr("class","arrow arrow"+E%O)},"drawArrow"),de=$((t,r)=>{const e=t.append("g").attr("class","commit-arrows");[...r.keys()].forEach(o=>{const n=r.get(o);n.parents&&n.parents.length>0&&n.parents.forEach(i=>{le(e,r.get(i),n,r)})})},"drawArrows"),he=$((t,r)=>{const e=t.append("g");r.forEach((o,n)=>{var i;const d=n%O,c=(i=T.get(o.name))==null?void 0:i.pos;if(c===void 0)throw new Error(`Position not found for branch ${o.name}`);const h=e.append("line");h.attr("x1",0),h.attr("y1",c),h.attr("x2",R),h.attr("y2",c),h.attr("class","branch branch"+d),p==="TB"?(h.attr("y1",z),h.attr("x1",c),h.attr("y2",R),h.attr("x2",c)):p==="BT"&&(h.attr("y1",R),h.attr("x1",c),h.attr("y2",z),h.attr("x2",c)),F.push(c);const a=o.name,s=rr(a),x=e.insert("rect"),g=e.insert("g").attr("class","branchLabel").insert("g").attr("class","label branch-label"+d);g.node().appendChild(s);const f=s.getBBox();x.attr("class","branchLabelBkg label"+d).attr("rx",4).attr("ry",4).attr("x",-f.width-4-((C==null?void 0:C.rotateCommitLabel)===!0?30:0)).attr("y",-f.height/2+8).attr("width",f.width+18).attr("height",f.height+4),g.attr("transform","translate("+(-f.width-14-((C==null?void 0:C.rotateCommitLabel)===!0?30:0))+", "+(c-f.height/2-1)+")"),p==="TB"?(x.attr("x",c-f.width/2-10).attr("y",0),g.attr("transform","translate("+(c-f.width/2-5)+", 0)")):p==="BT"?(x.attr("x",c-f.width/2-10).attr("y",R),g.attr("transform","translate("+(c-f.width/2-5)+", "+R+")")):x.attr("transform","translate(-19, "+(c-f.height/2)+")")})},"drawBranches"),$e=$(function(t,r,e,o,n){return T.set(t,{pos:r,index:e}),r+=50+(n?40:0)+(p==="TB"||p==="BT"?o.width/2:0),r},"setBranchPosition"),fe=$(function(t,r,e,o){var a,s;if(Vr(),v.debug("in gitgraph renderer",t+`
`,"id:",r,e),!C)throw new Error("GitGraph config not found");const n=(a=C.rotateCommitLabel)!=null?a:!1,i=o.db;A=i.getCommits();const d=i.getBranchesAsObjArray();p=i.getDirection();const c=yr(`[id="${r}"]`);let h=0;d.forEach((x,u)=>{var g;const f=rr(x.name),y=c.append("g"),E=y.insert("g").attr("class","branchLabel"),m=E.insert("g").attr("class","label branch-label");(g=m.node())==null||g.appendChild(f);const L=f.getBBox();h=$e(x.name,h,u,L,n),m.remove(),E.remove(),y.remove()}),V(c,A,!1),C.showBranches&&he(c,d),de(c,A),V(c,A,!0),pr.insertTitle(c,"gitTitleText",(s=C.titleTopMargin)!=null?s:0,i.getDiagramTitle()),xr(void 0,c,C.diagramPadding,C.useMaxWidth)},"draw"),ge={draw:fe},ue=$(t=>`
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0,1,2,3,4,5,6,7].map(r=>`
        .branch-label${r} { fill: ${t["gitBranchLabel"+r]}; }
        .commit${r} { stroke: ${t["git"+r]}; fill: ${t["git"+r]}; }
        .commit-highlight${r} { stroke: ${t["gitInv"+r]}; fill: ${t["gitInv"+r]}; }
        .label${r}  { fill: ${t["git"+r]}; }
        .arrow${r} { stroke: ${t["git"+r]}; }
        `).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${t.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelColor};}
  .commit-label-bkg { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${t.tagLabelFontSize}; fill: ${t.tagLabelColor};}
  .tag-label-bkg { fill: ${t.tagLabelBackground}; stroke: ${t.tagLabelBorder}; }
  .tag-hole { fill: ${t.textColor}; }

  .commit-merge {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }
  .commit-reverse {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
`,"getStyles"),ye=ue,Le={parser:Ur,db:Z,renderer:ge,styles:ye};export{Le as diagram};
