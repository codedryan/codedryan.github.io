var z=Object.defineProperty,U=Object.defineProperties;var $=Object.getOwnPropertyDescriptors;var B=Object.getOwnPropertySymbols;var q=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var A=(e,n,t)=>n in e?z(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,P=(e,n)=>{for(var t in n||(n={}))q.call(n,t)&&A(e,t,n[t]);if(B)for(var t of B(n))K.call(n,t)&&A(e,t,n[t]);return e},_=(e,n)=>U(e,$(n));var b=(e,n,t)=>new Promise((c,d)=>{var l=s=>{try{g(t.next(s))}catch(v){d(v)}},r=s=>{try{g(t.throw(s))}catch(v){d(v)}},g=s=>s.done?c(s.value):Promise.resolve(s.value).then(l,r);g((t=t.apply(e,n)).next())});import{_ as p,au as Q,av as W,aw as Z,ax as I,l as i,c as L,ay as ee,az as ne,ai as te,an as ie,aj as J,ah as se,aA as re,aB as oe,aC as ae}from"./mermaid.core-CAqkCmS1-CM8NaR-l.js";import{G as R}from"./graph-3zJxsO-i-C0CIU_ba.js";import{l as ce}from"./layout-sGZIJplX-Bh1u-GmM.js";import{ac as D}from"./bootstrap-Bf65uz2I.js";import{c as de}from"./clone-CEJtuQzg-DHIwSYDi.js";import{m as T}from"./min-BngCxx8g-CaLr7yid.js";import"../jse/index-index-D3Xb8oT_.js";import"./_baseUniq-BXtq6_NW-DmcqD6K1.js";function E(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:le(e),edges:fe(e)};return D(e.graph())||(n.value=de(e.graph())),n}function le(e){return T(e.nodes(),function(n){var t=e.node(n),c=e.parent(n),d={v:n};return D(t)||(d.value=t),D(c)||(d.parent=c),d})}function fe(e){return T(e.edges(),function(n){var t=e.edge(n),c={v:n.v,w:n.w};return D(n.name)||(c.name=n.name),D(t)||(c.value=t),c})}var u=new Map,C=new Map,M=new Map,ue=p(()=>{C.clear(),M.clear(),u.clear()},"clear"),k=p((e,n)=>{const t=C.get(n)||[];return i.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),ge=p((e,n)=>{const t=C.get(n)||[];return i.info("Descendants of ",n," is ",t),i.info("Edge is ",e),e.v===n||e.w===n?!1:t?t.includes(e.v)||k(e.v,n)||k(e.w,n)||t.includes(e.w):(i.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),j=p((e,n,t,c)=>{i.warn("Copying children of ",e,"root",c,"data",n.node(e),c);const d=n.children(e)||[];e!==c&&d.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(l=>{if(n.children(l).length>0)j(l,n,t,c);else{const r=n.node(l);i.info("cp ",l," to ",c," with parent ",e),t.setNode(l,r),c!==n.parent(l)&&(i.warn("Setting parent",l,n.parent(l)),t.setParent(l,n.parent(l))),e!==c&&l!==e?(i.debug("Setting parent",l,e),t.setParent(l,e)):(i.info("In copy ",e,"root",c,"data",n.node(e),c),i.debug("Not Setting parent for node=",l,"cluster!==rootId",e!==c,"node!==clusterId",l!==e));const g=n.edges(l);i.debug("Copying Edges",g),g.forEach(s=>{i.info("Edge",s);const v=n.edge(s.v,s.w,s.name);i.info("Edge data",v,c);try{ge(s,c)?(i.info("Copying as ",s.v,s.w,v,s.name),t.setEdge(s.v,s.w,v,s.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",s.v,"-->",s.w," rootId: ",c," clusterId:",e)}catch(x){i.error(x)}})}i.debug("Removing node",l),n.removeNode(l)})},"copy"),F=p((e,n)=>{const t=n.children(e);let c=[...t];for(const d of t)M.set(d,e),c=[...c,...F(d,n)];return c},"extractDescendants"),we=p((e,n,t)=>{const c=e.edges().filter(s=>s.v===n||s.w===n),d=e.edges().filter(s=>s.v===t||s.w===t),l=c.map(s=>({v:s.v===n?t:s.v,w:s.w===n?n:s.w})),r=d.map(s=>({v:s.v,w:s.w}));return l.filter(s=>r.some(v=>s.v===v.v&&s.w===v.w))},"findCommonEdges"),O=p((e,n,t)=>{const c=n.children(e);if(i.trace("Searching children of id ",e,c),c.length<1)return e;let d;for(const l of c){const r=O(l,n,t),g=we(n,t,r);if(r)if(g.length>0)d=r;else return r}return d},"findNonClusterChild"),G=p(e=>!u.has(e)||!u.get(e).externalConnections?e:u.has(e)?u.get(e).id:e,"getAnchorId"),ve=p((e,n)=>{if(!e||n>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",O(t,e,t)),C.set(t,F(t,e)),u.set(t,{id:O(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){const c=e.children(t),d=e.edges();c.length>0?(i.debug("Cluster identified",t,C),d.forEach(l=>{const r=k(l.v,t),g=k(l.w,t);r^g&&(i.warn("Edge: ",l," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",C.get(t)),u.get(t).externalConnections=!0)})):i.debug("Not a cluster ",t,C)});for(let t of u.keys()){const c=u.get(t).id,d=e.parent(c);d!==t&&u.has(d)&&!u.get(d).externalConnections&&(u.get(t).id=d)}e.edges().forEach(function(t){const c=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let d=t.v,l=t.w;if(i.warn("Fix XXX",u,"ids:",t.v,t.w,"Translating: ",u.get(t.v)," --- ",u.get(t.w)),u.get(t.v)||u.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),d=G(t.v),l=G(t.w),e.removeEdge(t.v,t.w,t.name),d!==t.v){const r=e.parent(d);u.get(r).externalConnections=!0,c.fromCluster=t.v}if(l!==t.w){const r=e.parent(l);u.get(r).externalConnections=!0,c.toCluster=t.w}i.warn("Fix Replacing with XXX",d,l,t.name),e.setEdge(d,l,c,t.name)}}),i.warn("Adjusted Graph",E(e)),Y(e,0),i.trace(u)},"adjustClustersAndEdges"),Y=p((e,n)=>{var t,c;if(i.warn("extractor - ",n,E(e),e.children("D")),n>10){i.error("Bailing out");return}let d=e.nodes(),l=!1;for(const r of d){const g=e.children(r);l=l||g.length>0}if(!l){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",d,n);for(const r of d)if(i.debug("Extracting node",r,u,u.has(r)&&!u.get(r).externalConnections,!e.parent(r),e.node(r),e.children("D")," Depth ",n),!u.has(r))i.debug("Not a cluster",r,n);else if(!u.get(r).externalConnections&&e.children(r)&&e.children(r).length>0){i.warn("Cluster without external connections, without a parent and with children",r,n);let s=e.graph().rankdir==="TB"?"LR":"TB";(c=(t=u.get(r))==null?void 0:t.clusterData)!=null&&c.dir&&(s=u.get(r).clusterData.dir,i.warn("Fixing dir",u.get(r).clusterData.dir,s));const v=new R({multigraph:!0,compound:!0}).setGraph({rankdir:s,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",E(e)),j(r,e,v,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:u.get(r).clusterData,label:u.get(r).label,graph:v}),i.warn("New graph after copy node: (",r,")",E(v)),i.debug("Old graph after copy",E(e))}else i.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!u.get(r).externalConnections," no parent: ",!e.parent(r)," children ",e.children(r)&&e.children(r).length>0,e.children("D"),n),i.debug(u);d=e.nodes(),i.warn("New list of nodes",d);for(const r of d){const g=e.node(r);i.warn(" Now next level",r,g),g!=null&&g.clusterNode&&Y(g.graph,n+1)}},"extractor"),H=p((e,n)=>{if(n.length===0)return[];let t=Object.assign([],n);return n.forEach(c=>{const d=e.children(c),l=H(e,d);t=[...t,...l]}),t},"sorter"),me=p(e=>H(e,e.children()),"sortNodesByHierarchy"),V=p((e,n,t,c,d,l)=>b(null,null,function*(){i.warn("Graph in recursive render:XAX",E(n),d);const r=n.graph().rankdir;i.trace("Dir in recursive render - dir:",r);const g=e.insert("g").attr("class","root");n.nodes()?i.info("Recursive render XXX",n.nodes()):i.info("No nodes found for",n),n.edges().length>0&&i.info("Recursive edges",n.edge(n.edges()[0]));const s=g.insert("g").attr("class","clusters"),v=g.insert("g").attr("class","edgePaths"),x=g.insert("g").attr("class","edgeLabels"),w=g.insert("g").attr("class","nodes");yield Promise.all(n.nodes().map(function(f){return b(this,null,function*(){const a=n.node(f);if(d!==void 0){const o=JSON.parse(JSON.stringify(d.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,o.height,`
Parent cluster`,d.height),n.setNode(d.id,o),n.parent(f)||(i.trace("Setting parent",f,d.id),n.setParent(f,d.id,o))}if(i.info("(Insert) Node XXX"+f+": "+JSON.stringify(n.node(f))),a!=null&&a.clusterNode){i.info("Cluster identified XBX",f,a.width,n.node(f));const{ranksep:o,nodesep:h}=n.graph();a.graph.setGraph(_(P({},a.graph.graph()),{ranksep:o+25,nodesep:h}));const N=yield V(w,a.graph,t,c,n.node(f),l),S=N.elem;ee(a,S),a.diff=N.diff||0,i.info("New compound node after recursive render XAX",f,"width",a.width,"height",a.height),ne(S,a)}else n.children(f).length>0?(i.trace("Cluster - the non recursive path XBX",f,a.id,a,a.width,"Graph:",n),i.trace(O(a.id,n)),u.set(a.id,{id:O(a.id,n),node:a})):(i.trace("Node - the non recursive path XAX",f,w,n.node(f),r),yield te(w,n.node(f),{config:l,dir:r}))})})),yield p(()=>b(null,null,function*(){const f=n.edges().map(function(a){return b(this,null,function*(){const o=n.edge(a.v,a.w,a.name);i.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),i.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(n.edge(a))),i.info("Fix",u,"ids:",a.v,a.w,"Translating: ",u.get(a.v),u.get(a.w)),yield ae(x,o)})});yield Promise.all(f)}),"processEdges")(),i.info("Graph before layout:",JSON.stringify(E(n))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),ce(n),i.info("Graph after layout:",JSON.stringify(E(n)));let y=0,{subGraphTitleTotalMargin:X}=ie(l);return yield Promise.all(me(n).map(function(f){return b(this,null,function*(){var a;const o=n.node(f);if(i.info("Position XBX => "+f+": ("+o.x,","+o.y,") width: ",o.width," height: ",o.height),o!=null&&o.clusterNode)o.y+=X,i.info("A tainted cluster node XBX1",f,o.id,o.width,o.height,o.x,o.y,n.parent(f)),u.get(o.id).node=o,J(o);else if(n.children(f).length>0){i.info("A pure cluster node XBX1",f,o.id,o.x,o.y,o.width,o.height,n.parent(f)),o.height+=X,n.node(o.parentId);const h=(o==null?void 0:o.padding)/2||0,N=((a=o==null?void 0:o.labelBBox)==null?void 0:a.height)||0,S=N-h||0;i.debug("OffsetY",S,"labelHeight",N,"halfPadding",h),yield se(s,o),u.get(o.id).node=o}else{const h=n.node(o.parentId);o.y+=X/2,i.info("A regular node XBX1 - using the padding",o.id,"parent",o.parentId,o.width,o.height,o.x,o.y,"offsetY",o.offsetY,"parent",h,h==null?void 0:h.offsetY,o),J(o)}})})),n.edges().forEach(function(f){const a=n.edge(f);i.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(a),a),a.points.forEach(S=>S.y+=X/2);const o=n.node(f.v);var h=n.node(f.w);const N=re(v,a,u,t,o,h,c);oe(a,N)}),n.nodes().forEach(function(f){const a=n.node(f);i.info(f,a.type,a.diff),a.isGroup&&(y=a.diff)}),i.warn("Returning from recursive render XAX",g,y),{elem:g,diff:y}}),"recursiveRender"),xe=p((e,n)=>b(null,null,function*(){var t,c,d,l,r,g;const s=new R({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((t=e.config)==null?void 0:t.nodeSpacing)||((d=(c=e.config)==null?void 0:c.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((l=e.config)==null?void 0:l.rankSpacing)||((g=(r=e.config)==null?void 0:r.flowchart)==null?void 0:g.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),v=n.select("g");Q(v,e.markers,e.type,e.diagramId),W(),Z(),I(),ue(),e.nodes.forEach(w=>{s.setNode(w.id,P({},w)),w.parentId&&s.setParent(w.id,w.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(w=>{if(w.start===w.end){const m=w.start,y=m+"---"+m+"---1",X=m+"---"+m+"---2",f=s.node(m);s.setNode(y,{domId:y,id:y,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),s.setParent(y,f.parentId),s.setNode(X,{domId:X,id:X,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),s.setParent(X,f.parentId);const a=structuredClone(w),o=structuredClone(w),h=structuredClone(w);a.label="",a.arrowTypeEnd="none",a.id=m+"-cyclic-special-1",o.arrowTypeStart="none",o.arrowTypeEnd="none",o.id=m+"-cyclic-special-mid",h.label="",f.isGroup&&(a.fromCluster=m,h.toCluster=m),h.id=m+"-cyclic-special-2",h.arrowTypeStart="none",s.setEdge(m,y,a,m+"-cyclic-special-0"),s.setEdge(y,X,o,m+"-cyclic-special-1"),s.setEdge(X,m,h,m+"-cyc<lic-special-2")}else s.setEdge(w.start,w.end,P({},w),w.id)}),i.warn("Graph at first:",JSON.stringify(E(s))),ve(s),i.warn("Graph after XAX:",JSON.stringify(E(s)));const x=L();yield V(v,s,e.type,e.diagramId,void 0,x)}),"render");export{xe as render};
